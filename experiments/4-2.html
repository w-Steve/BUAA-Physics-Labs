<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基物实验助手- 电桥法测电阻</title>
    <!-- 公共样式 (与1-1共用) -->
    <link rel="stylesheet" href="style.css">
    <!-- 公共工具库 (含存储、表格生成、键盘导航、格式修约等) -->
    <script src="common.js"></script>
    <!-- MathJax 配置 (与1-1相同) -->
    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']], processEscapes: true },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-svg.js" id="MathJax-script" async></script>
</head>
<body>
<div class="container">
    <div class="page-title">电桥法测电阻</div>

    <!-- 实验要点提示 -->
    <div class="tip-box">
        <strong>Tips</strong><br>
        • 待测电阻 $R_x = \sqrt{R_N \cdot R_N'}$<br>
        • 电阻箱误差 $\Delta R_k = R_0 + \sum (a_i\% \times R_i)$  ($R_i$为各档位示值)<br>
        • 电桥灵敏度 $S = \Delta x / \Delta R$，灵敏度引入误差 $\Delta_{\text{灵}} = 0.2 / S$<br>
        • 合成不确定度 $u(R_x) = R_x \sqrt{ \left(\frac{u(R_N)}{2R_N}\right)^2 + \left(\frac{u(R_N')}{2R_N'}\right)^2 }$<br>
    </div>

    <!-- 原始数据录入区 -->
    <div class="section">
        <div class="section-title">原始数据录入</div>

        <!-- 基本测量参数 -->
        <div class="top-input-group" style="flex-wrap: wrap; gap: 1.5rem; margin-bottom: 2rem;">
            <div class="top-input"><label>$R_N$ (Ω):</label><input type="number" id="rn" class="save-input cell-input" step="0.01" value="1000.00"></div>
            <div class="top-input"><label>$R_N'$ (Ω):</label><input type="number" id="rnPrime" class="save-input cell-input" step="0.01" value="2000.00"></div>
            <div class="top-input"><label>$\Delta x$ (格):</label><input type="number" id="deltaX" class="save-input cell-input" step="0.1" value="10.0"></div>
            <div class="top-input"><label>$\Delta R$ (Ω):</label><input type="number" id="deltaR" class="save-input cell-input" step="0.01" value="5.00"></div>
            <div class="top-input"><label>电阻箱固定误差$R_0$ (Ω):</label><input type="number" id="r0" class="save-input cell-input" step="0.001" value="0.020"></div>
        </div>

        <!-- 电阻箱准确度等级表格 -->
        <div style="margin-bottom: 1rem;">
            <div style="font-weight: 500; margin-bottom: 0.5rem;">电阻箱准确度等级 $a_i$ (%)</div>
            <div id="acc-table-container" class="data-table"></div>
        </div>
    </div>

    <!-- 操作按钮组 -->
    <div class="action-buttons">
        <button class="primary" id="calculateBtn">计算并保存</button>
        <button id="saveBtn">仅保存数据</button>
    </div>

    <!-- 主要结果卡片 (使用修约后的数值) -->
    <div class="section" id="resultMain" style="display: none;">
        <div class="section-title">测量结果</div>
        <div class="result-grid">
            <div class="result-card"><div class="result-label">待测电阻 $R_x$ (Ω)</div><div class="result-value" id="rx_val">—</div></div>
            <div class="result-card"><div class="result-label">合成不确定度 $u(R_x)$ (Ω)</div><div class="result-value" id="urx_val">—</div></div>
            <div class="result-card"><div class="result-label">相对不确定度 $u(R_x)/R_x$</div><div class="result-value" id="rel_urx_val">—</div></div>
            <div class="result-card"><div class="result-label">灵敏度 $S$ (格/Ω)</div><div class="result-value" id="sens_val">—</div></div>
            <div class="result-card"><div class="result-label">$u(S)$ (格/Ω)</div><div class="result-value" id="usens_val">—</div></div>
        </div>
    </div>

    <!-- 详细计算过程 (已移除原始数据步骤) -->
    <div class="section" id="processSection" style="display: none;">
        <div class="section-title">详细计算过程</div>
        <div class="process-container" id="calculationProcess"></div>
    </div>

    <!-- 免责声明 -->
    <div class="disclaimer" style="text-align: center;">开源项目禁止商用 ｜ 自行核对计算数据</div>
</div>

<script>
(function() {
    const APP_KEY = '4-2';

    // ---------- 从DOM获取所有输入值 ----------
    function getInputs() {
        const rn = parseFloat(document.getElementById('rn').value);
        const rnPrime = parseFloat(document.getElementById('rnPrime').value);
        const deltaX = parseFloat(document.getElementById('deltaX').value);
        const deltaR = parseFloat(document.getElementById('deltaR').value);
        const r0 = parseFloat(document.getElementById('r0').value);

        const accValues = [];
        for (let i = 1; i <= 5; i++) {
            const inp = document.getElementById(`acc${i}`);
            accValues.push(inp ? parseFloat(inp.value) : NaN);
        }

        return {
            rn, rnPrime, deltaX, deltaR, r0,
            acc1000: accValues[0], acc100: accValues[1], acc10: accValues[2],
            acc1: accValues[3], acc01: accValues[4]
        };
    }

    // ---------- 数据有效性检查 ----------
    function isValid(data) {
        const { rn, rnPrime, deltaX, deltaR, r0, acc1000, acc100, acc10, acc1, acc01 } = data;
        if (isNaN(rn) || rn <= 0) return false;
        if (isNaN(rnPrime) || rnPrime <= 0) return false;
        if (isNaN(deltaX) || deltaX <= 0) return false;
        if (isNaN(deltaR) || deltaR <= 0) return false;
        if (isNaN(r0) || r0 < 0) return false;
        if (isNaN(acc1000) || acc1000 <= 0) return false;
        if (isNaN(acc100) || acc100 <= 0) return false;
        if (isNaN(acc10) || acc10 <= 0) return false;
        if (isNaN(acc1) || acc1 <= 0) return false;
        if (isNaN(acc01) || acc01 <= 0) return false;
        return true;
    }

    // ---------- 辅助：计算单个电阻箱的 ΔR_k ----------
    function computeDeltaR(R, R0, accMap) {
        const rounded = Math.round(R * 10) / 10;
        const intPart = Math.floor(rounded);
        const fracPart = Math.round((rounded - intPart) * 10);

        const d1000 = Math.floor(intPart / 1000) % 10;
        const d100  = Math.floor(intPart / 100) % 10;
        const d10   = Math.floor(intPart / 10) % 10;
        const d1    = intPart % 10;
        const d01   = fracPart;

        let sum = 0;
        sum += accMap[1000] * (d1000 * 1000);
        sum += accMap[100]  * (d100 * 100);
        sum += accMap[10]   * (d10 * 10);
        sum += accMap[1]    * (d1 * 1);
        sum += accMap[0.1]  * (d01 * 0.1);
        return R0 + sum;
    }

    // ---------- 核心计算 ----------
    function compute(data) {
        const { rn, rnPrime, deltaX, deltaR, r0, acc1000, acc100, acc10, acc1, acc01 } = data;

        const accMap = {
            1000: acc1000 / 100,
            100: acc100 / 100,
            10: acc10 / 100,
            1: acc1 / 100,
            0.1: acc01 / 100
        };

        const deltaRn = computeDeltaR(rn, r0, accMap);
        const deltaRnPrime = computeDeltaR(rnPrime, r0, accMap);
        const uRn = deltaRn / Math.sqrt(3);
        const uRnPrime = deltaRnPrime / Math.sqrt(3);
        const rx = Math.sqrt(rn * rnPrime);
        const term1 = Math.pow(uRn / (2 * rn), 2);
        const term2 = Math.pow(uRnPrime / (2 * rnPrime), 2);
        const relU_rx = Math.sqrt(term1 + term2);
        const uRx = rx * relU_rx;

        const sensitivity = deltaX / deltaR;
        const deltaSens = 0.2 / sensitivity;
        const uSens = deltaSens / Math.sqrt(3);

        // 分解档位用于展示
        const digits = (val) => ({
            d1000: Math.floor(val/1000)%10,
            d100: Math.floor(val/100)%10,
            d10: Math.floor(val/10)%10,
            d1: Math.floor(val)%10,
            d01: Math.round((val - Math.floor(val))*10)
        });

        return {
            rn, rnPrime, deltaX, deltaR, r0,
            acc1000, acc100, acc10, acc1, acc01,
            deltaRn, deltaRnPrime, uRn, uRnPrime,
            rx, uRx, relU_rx,
            sensitivity, deltaSens, uSens,
            digitsRn: digits(rn),
            digitsRnPrime: digits(rnPrime)
        };
    }

    // ---------- 渲染详细计算过程 (已移除原始数据步骤) ----------
    function renderProcess(res) {
        const f = (x) => x.toFixed(6);
        const f2 = (x) => x.toFixed(4);

        // 使用修约函数获得最终结果的标准表示
        const [rxRounded, uRxRounded] = window.ExperimentUtils.formatResultWithUncertainty(res.rx, res.uRx);
        const [sensRounded, uSensRounded] = window.ExperimentUtils.formatResultWithUncertainty(res.sensitivity, res.uSens);

        const html = `
        <div class="calculation-step">
            <div class="step-title">1. 计算电阻箱误差 $\\Delta R_N$ 和 $\\Delta R_N'$</div>
            <div class="step-formula">$$\\Delta R_N = ${res.r0.toFixed(4)} + [${f(res.acc1000/100)}(${res.digitsRn.d1000}\\times1000) + ${f(res.acc100/100)}(${res.digitsRn.d100}\\times100) + ${f(res.acc10/100)}(${res.digitsRn.d10}\\times10) + ${f(res.acc1/100)}(${res.digitsRn.d1}\\times1) + ${f(res.acc01/100)}(${res.digitsRn.d01}\\times0.1)] = ${f(res.deltaRn)}\\ \\Omega$$</div>
            <div class="step-formula">$$\\Delta R_N' = ${res.r0.toFixed(4)} + [${f(res.acc1000/100)}(${res.digitsRnPrime.d1000}\\times1000) + ${f(res.acc100/100)}(${res.digitsRnPrime.d100}\\times100) + ${f(res.acc10/100)}(${res.digitsRnPrime.d10}\\times10) + ${f(res.acc1/100)}(${res.digitsRnPrime.d1}\\times1) + ${f(res.acc01/100)}(${res.digitsRnPrime.d01}\\times0.1)] = ${f(res.deltaRnPrime)}\\ \\Omega$$</div>
        </div>

        <div class="calculation-step">
            <div class="step-title">2. B类不确定度 $u(R_N)$, $u(R_N')$</div>
            <div class="step-formula">$$u(R_N) = \\frac{\\Delta R_N}{\\sqrt{3}} = \\frac{${f(res.deltaRn)}}{1.73205} = ${f(res.uRn)}\\ \\Omega$$</div>
            <div class="step-formula">$$u(R_N') = \\frac{\\Delta R_N'}{\\sqrt{3}} = \\frac{${f(res.deltaRnPrime)}}{1.73205} = ${f(res.uRnPrime)}\\ \\Omega$$</div>
        </div>

        <div class="calculation-step">
            <div class="step-title">3. 待测电阻 $R_x$ 及不确定度 $u(R_x)$</div>
            <div class="step-formula">$$R_x = \\sqrt{R_N R_N'} = \\sqrt{${res.rn.toFixed(4)} \\times ${res.rnPrime.toFixed(4)}} = ${f(res.rx)}\\ \\Omega$$</div>
            <div class="step-formula">相对合成分量：$$\\frac{u(R_N)}{2R_N} = \\frac{${f(res.uRn)}}{2\\times${res.rn.toFixed(4)}} = ${f(res.uRn/(2*res.rn))},\\quad \\frac{u(R_N')}{2R_N'} = ${f(res.uRnPrime/(2*res.rnPrime))}$$</div>
            <div class="step-formula">$$\\frac{u(R_x)}{R_x} = \\sqrt{\\left(\\frac{u(R_N)}{2R_N}\\right)^2 + \\left(\\frac{u(R_N')}{2R_N'}\\right)^2} = \\sqrt{(${f(res.uRn/(2*res.rn))})^2 + (${f(res.uRnPrime/(2*res.rnPrime))})^2} = ${f(res.relU_rx)}$$</div>
            <div class="step-formula">$$u(R_x) = R_x \\times \\frac{u(R_x)}{R_x} = ${f(res.rx)} \\times ${f(res.relU_rx)} = ${f(res.uRx)}\\ \\Omega$$</div>
        </div>

        <div class="calculation-step">
            <div class="step-title">4. 电桥灵敏度 $S$ 及其不确定度</div>
            <div class="step-formula">$$S = \\frac{\\Delta x}{\\Delta R} = \\frac{${res.deltaX.toFixed(2)}}{${res.deltaR.toFixed(4)}} = ${f(res.sensitivity)}\\ \\text{格/Ω}$$</div>
            <div class="step-formula">灵敏度引入误差 $$\\Delta_{\\text{灵}} = \\frac{0.2}{S} = \\frac{0.2}{${f(res.sensitivity)}} = ${f(res.deltaSens)}\\ \\Omega$$</div>
            <div class="step-formula">灵敏度不确定度$$u(S) = \\frac{\\Delta_{\\text{灵}}}{\\sqrt{3}} = \\frac{${f(res.deltaSens)}}{1.73205} = ${f(res.uSens)}\\ \\text{格/Ω}$$</div>
        </div>

        <div class="calculation-step">
            <div class="step-title">5. 最终结果</div>
            <div class="step-result" style="font-size:1.2rem;">$R_x = (${rxRounded} \\pm ${uRxRounded})\\ \\Omega$</div>
            <div class="step-result">相对不确定度 = $\\frac{u(R_x)}{R_x} = ${(res.relU_rx*100).toFixed(2)}$ %</div>
            <div class="step-result">灵敏度 $S = ${sensRounded}\\ \\text{格/Ω}$，$u(S) = ${uSensRounded}\\ \\text{格/Ω}$</div>
        </div>
        `;

        document.getElementById('calculationProcess').innerHTML = html;
        window.ExperimentUtils.renderMath(document.getElementById('calculationProcess'));
    }

    // ---------- 显示主要结果卡片 (应用修约) ----------
    function displayResults(res) {
        // 使用 common.js 的修约函数
        const [rxStr, uRxStr] = window.ExperimentUtils.formatResultWithUncertainty(res.rx, res.uRx);
        const [sensStr, uSensStr] = window.ExperimentUtils.formatResultWithUncertainty(res.sensitivity, res.uSens);

        document.getElementById('rx_val').innerText = rxStr;
        document.getElementById('urx_val').innerText = uRxStr;
        document.getElementById('rel_urx_val').innerText = res.relU_rx.toFixed(6);
        document.getElementById('sens_val').innerText = sensStr;
        document.getElementById('usens_val').innerText = uSensStr;

        renderProcess(res);
        document.getElementById('resultMain').style.display = 'block';
        document.getElementById('processSection').style.display = 'block';
    }

    // ---------- 计算入口 ----------
    function calculate() {
        const data = getInputs();
        if (!isValid(data)) {
            alert('数据不完整或格式错误，请确保所有测量值均为正数 (R₀可为零)');
            return;
        }
        try {
            const results = compute(data);
            displayResults(results);
            window.ExperimentUtils.Storage.saveFromInputs(APP_KEY);
        } catch (e) {
            console.error(e);
            alert('计算过程出错，请检查数据');
        }
    }

    function saveOnly() {
        window.ExperimentUtils.Storage.saveFromInputs(APP_KEY);
        alert('数据已保存');
    }

    // ---------- 页面初始化 ----------
    window.addEventListener('DOMContentLoaded', function() {
        const TableGenerator = window.ExperimentUtils.TableGenerator;

        // 生成准确度等级表格
        TableGenerator.generateInputTable('acc-table-container', {
            rows: 1,
            cols: 5,
            colHeaders: ['','1000 Ω', '100 Ω', '10 Ω', '1 Ω', '0.1 Ω'],
            rowHeaders: ['准确度等级 aᵢ (%)'],
            prefix: 'acc',
            defaultValues: [0.1, 0.1, 0.1, 0.5, 5.0]
        });

        // 加载保存的数据
        window.ExperimentUtils.Storage.loadToInputs(APP_KEY);

        // 键盘导航
        window.ExperimentUtils.KeyboardNav.init('#acc-table-container', 5);

        // 深色模式
        window.ExperimentUtils.ThemeManager.init();

        // 绑定按钮
        document.getElementById('calculateBtn').addEventListener('click', calculate);
        document.getElementById('saveBtn').addEventListener('click', saveOnly);
    });
})();
</script>
</body>
</html>